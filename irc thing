[18:52] == somebody1234 [3ce27018@gateway/web/freenode/ip.60.226.112.24] has joined #pypy
[18:52] -ChanServ- [#pypy] Welcome!
[18:54] == marr [~ccc@87-205-172-190.adsl.inetia.pl] has joined #pypy
[18:55] <somebody1234> where would be the best place to ask questions about writing fast interpreters?
[18:58] == vkirilichev [~vkirilich@p578bbe9f.dip0.t-ipconnect.de] has joined #pypy
[18:59] <kenaan> arigo py3.5 01bd875e7563 /pypy/module/math/app_math.py: fix for test
[18:59] <kenaan> arigo py3.5 3fff80d67303 /pypy/module/array/: fix error message
[18:59] <arigato> somebody1234: start here
[19:00] <somebody1234> idk if it's relevant though, I'm not intending to use the PyPy toolchain
[19:01] <arigato> we're happy to discuss general interpreter implementation issues
[19:01] <somebody1234> So I have no idea how to make things easily optimizeable without pre-optimizing
[19:03] <arigato> you'll have to develop a bit more, I don't know what you mean by pre-optimizing
[19:04] <somebody1234> i mean premature optimization
[19:06] == romerocesar [~cesar@c-50-159-44-90.hsd1.wa.comcast.net] has joined #pypy
[19:07] <bbot2> Success: http://buildbot.pypy.org/builders/jit-benchmark-linux-x86-32/builds/2813
[19:08] <somebody1234> e.g. things like: for scoping, is having a varname -> index map and a vector of objects in the scope any faster than a varname -> object map
[19:10] <arigato> yes, the general rule is that dict lookups (or other searches) are slower than indexing an array
[19:11] <arigato> in Python for example, the local variables are arranged in an array by the bytecode compiler, and the bytecode itself refers to local variables by index
[19:11] == romerocesar [~cesar@c-50-159-44-90.hsd1.wa.comcast.net] has quit [Ping timeout: 260 seconds]
[19:11] <arigato> also, to start with, you need a bytecode, not an AST, because it's a bit faster
[19:16] <somebody1234> so it's still faster to translate AST to bytecode than to use AST directly?
[19:16] <arigato> yes
[19:16] <arigato> (at least, it seems so in practice)
[19:17] <somebody1234> oh, okay
[19:24] == agates [agatesmatr@gateway/shell/matrix.org/x-xrfczyftszzgehqd] has quit [Ping timeout: 245 seconds]
[19:25] == kurtbrose[m] [kurtbrosem@gateway/shell/matrix.org/x-efyuzudtaahhusvw] has quit [Ping timeout: 250 seconds]
[19:25] == bendlas [bendlasmat@gateway/shell/matrix.org/x-ykvfonfscrsclbgy] has quit [Ping timeout: 250 seconds]
[19:26] <somebody1234> are class attributes also put in an array in Python?
[19:26] <somebody1234> *attributes/class attributes
[19:27] <arigato> CPython only puts locals in an array; everything else is dynamic
[19:27] <arigato> PyPy arranges attributes in an array anyway
[19:27] <arigato> but that's more advanced: see
[19:29] <arigato> https://morepypy.blogspot.ch/search?q=map
[19:29] == xando [uid26666@gateway/web/irccloud.com/x-ihcucnxcolcwtbvs] has joined #pypy
[19:29] <arigato> that's not necessarily faster, if you have only an interpreter and no JIT compiler
[19:29] <arigato> although it could be made faster with enough efforts, I think
[19:29] == antocuni [~antocuni@host9-127-dynamic.16-79-r.retail.telecomitalia.it] has joined #pypy
[19:36] <arigato> all I said only applies for languages like Python and Javascript, where objects can have random attributes added at any point in time
[19:36] <arigato> Smalltalk for example has objects with fixed attributes
[19:37] <arigato> so in Smalltalk, of course the attributes are in a vector
[19:37] <somebody1234> normal Python objects can have random attributes added?
[19:37] <arigato> yes
[19:37] <arigato> instances of user-defined classes can
[19:37] <arigato> (not objects of built-in types)
[19:38] <arigato> see notably https://morepypy.blogspot.ch/2010/11/efficiently-implementing-python-objects.html
[19:38] <kenaan> arigo py3.5 a7657f5b543d /pypy/module/cmath/: cmath.isclose()
[19:47] == Tiberium [~user@178.205.62.28] has joined #pypy
[19:48] <kenaan> arigo py3.5 db1c76818220 /lib-python/3/test/test_generators.py: accept AttributeError in this case too
[19:50] == krono [~krono@unaffiliated/krono] has quit [Remote host closed the connection]
[19:53] == Tiberium [~user@178.205.62.28] has quit [Remote host closed the connection]
[19:55] <kenaan> arigo py3.5 763c24bd5dca /pypy/: sys.is_finalizing()
[19:57] <bbot2> Failure: http://buildbot.pypy.org/builders/pypy-c-jit-linux-armhf-v7/builds/1122
[20:03] == maybekoo2 [~kook@236.152.broadband3.iol.cz] has joined #pypy
[20:05] <arigato> (lots of snow here)
[20:07] == gbutnaru [~gbutnaru@81.180.223.42] has quit [Ping timeout: 268 seconds]
[20:08] == vkirilic_ [~vkirilich@p578bbe9f.dip0.t-ipconnect.de] has joined #pypy
[20:08] == vkirilichev [~vkirilich@p578bbe9f.dip0.t-ipconnect.de] has quit [Read error: Connection reset by peer]
[20:11] == krono [~krono@unaffiliated/krono] has joined #pypy
[20:11] <somebody1234> how would i start on bytecode design
[20:12] <somebody1234> i guess mostly how low/high level should instructions be
[20:15] <arigato> I'd say as high as possible
[20:16] <arigato> the Python stack-based basics are good imho: for example, "a = b + c" generates 4 instructions: LOAD 1, LOAD 2, ADD, STORE 3"
[20:16] <arigato> the ADD bytecode is the same as the + in the language, so it'll do the type dispatch
[20:17] == Tiberium [~user@178.205.62.28] has joined #pypy
[20:18] <arigato> modern Python bytecodes got more and more detached from the language, to the point that a single syntax element can generate a dozen low-level bytecodes instead of a single high-level one, which is bad imho
[20:22] == gbutnaru [~gbutnaru@81.180.223.46] has joined #pypy
[20:22] == bendlas [bendlasmat@gateway/shell/matrix.org/x-cungbanudogmtshi] has joined #pypy
[20:24] == OOPMan [~OOPMan@154.66.206.100] has quit [Quit: Konversation terminated!]
[20:28] == kurtbrose[m] [kurtbrosem@gateway/shell/matrix.org/x-sykdublfbuvxitrd] has joined #pypy
[20:28] == agates [agatesmatr@gateway/shell/matrix.org/x-wrpkimvxxkffaewm] has joined #pypy
[20:41] == amaury [~amauryfa@104.132.117.93] has joined #pypy